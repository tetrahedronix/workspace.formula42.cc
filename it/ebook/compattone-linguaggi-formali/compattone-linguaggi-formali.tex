%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dictionary
% LaTeX Template
% Version 1.1 (6/8/17)
%
% This template was downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Vel (vel@latextemplates.com) inspired by a template by Marc Lavaud
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[10pt,a4paper,twoside]{article} % 10pt font size, A4 paper and two-sided margins

\usepackage[top=3.5cm,bottom=3.5cm,left=3.7cm,right=4.7cm,columnsep=30pt]{geometry} % Document margins and spacings

\usepackage[italian]{babel}

\usepackage{amsmath}
\usepackage{amsfonts}

\usepackage[utf8]{inputenc} % Required for inputting international characters
\usepackage[T1]{fontenc} % Output font encoding for international characters

\usepackage{lettrine}
\usepackage{palatino} % Use the Palatino font

\usepackage{microtype} % Improves spacing

\usepackage{multicol} % Required for splitting text into multiple columns

\usepackage[bf,sf,center]{titlesec} % Required for modifying section titles - bold, sans-serif, centered

\usepackage{fancyhdr} % Required for modifying headers and footers
\fancyhead[L]{\textsf{\rightmark}} % Top left header
\fancyhead[R]{\textsf{\leftmark}} % Top right header
\renewcommand{\headrulewidth}{1.4pt} % Rule under the header
\fancyfoot[C]{\textbf{\textsf{\thepage}}} % Bottom center footer
\renewcommand{\footrulewidth}{1.4pt} % Rule under the footer
\pagestyle{fancy} % Use the custom headers and footers throughout the document
 % Defines the command to print each word on the page, \markboth{}{} prints the first word on the page in the top left header and the last word in the top right
\newcommand{\entry}[4]{\noindent\textbf{\MakeUppercase{#1}}\markboth{#1}{#1}\par
%\noindent{(#2)}\ \textit{#3}\par % Spostato tra il nome e il righello
\vspace{0.5\baselineskip} % Riduci lo spazio verticale
\noindent\hrule\par
\vspace{0.5\baselineskip} % Riduci lo spazio verticale
{(#2)}\ \textit{#3}\ $\bullet$\
{#4}\\% 
%\vspace{0.1\baselineskip} % Riduci lo spazio verticale
%\noindent\hrulefill\par
}
%\usepackage{natbib}
%\bibliographystyle{plainnat}
%\usepackage[
%backend=biber,
%style=alphabetic,
%sorting=ynt,
%citestyle=authoryear
%]{biblatex}
%----------------------------------------------------------------------------------------

\begin{document}

%----------------------------------------------------------------------------------------
%	SECTION A
%----------------------------------------------------------------------------------------
\section*{A}

\begin{multicols}{2}

\entry{Alfabeto}{Character set}{Nome}{Un -- è un insieme finito e non 
vuoto di simboli. Si indica con la lettera greca maiuscola $\Sigma$. Tra gli --
più comuni ci sono quello binario, $\Sigma=\lbrace 0,1\rbrace$, l'insieme
delle lettere minuscole (o maiuscole) della lingua italiana, le cifre decimali,
ecc. }

\end{multicols}

%----------------------------------------------------------------------------------------
%	SECTION B
%----------------------------------------------------------------------------------------
\section*{B}


%----------------------------------------------------------------------------------------
%	SECTION D 
%----------------------------------------------------------------------------------------
\section*{D}

\begin{multicols*}{2}
\entry{Deduttiva, Dimostrazione}{Deductive proof}{Agg.}{Una dimostrazione -- è un processo
logico che consiste in una sequenza di passi giustificati, partendo da un'ipotesi
o un insieme di ipotesi, al fine di raggiungere una conclusione o tesi. Ogni
passo della dimostrazione deve essere logicamente valido, seguendo regole e
principi ben definiti, in modo che la validità della tesi sia garantita a partire
dalle ipotesi iniziali.}
\end{multicols*}

%----------------------------------------------------------------------------------------
%	SECTION I
%----------------------------------------------------------------------------------------
\section*{I}

\begin{multicols*}{2}
\entry{Induttiva, Dimostrazione}{Inductive proof}{Agg.}{Si tratta di un tipo di dimostrazione che,
in modo ricorsivo, verifica la validità di un enunciato parametrizzato partendo
da considerazioni specifiche. Queste considerazioni dipendono da valori ristretti
del parametro, estendendosi gradualmente fino a confermare la sua verità per
valori più generali.    

\textit{Esempio}. --- Sia $S(n)$ una proposizione dipendente da un numero
naturale $n$. Per esempio, $S(n)$ potrebbe essere la formula per calcolare la
somma dei primi $n$ numeri naturali:
\[
\sum_{i=1}^{n}i=\frac{n(n+1)}{2}    
\]
La formula stabilisce che per ogni intero $n$ si ha
\[
1+2+...+(n-1)+n=\frac{n(n+1)}{2}.
\]
La dimostrazione induttiva consiste nel mostrare che la formula è vera per un
valore particolare detto \textit{base}, in questo caso si sceglie $n=1$ e si
ottiene proprio l'uguaglianza
\[
1=\frac{1(1+1)}{2}.
\]
Dopodiché si dimostra l'implicazione
\begin{align*}
    &\sum_{i=1}^{n}i=\frac{n(n+1)}{2}\Rightarrow \\
    &\Rightarrow\sum_{i=1}^{n+1}i=\frac{(n+1)(n+2)}{2},
\end{align*}
cioè che la verità della formula con il valore $n+1$ dipende dalla verità della
formula con $n$, detta \textit{ipotesi induttiva}.
Infatti, si ha che
\begin{align*}
    \sum_{i=1}^{n+1}&=1+2+...+n+(n+1)=\\
    &=\frac{n(n+1)}{2}+(n+1)= \\
    &= ... =\frac{(n+1)(n+2)}{2}.
\end{align*}
}
\end{multicols*}

%----------------------------------------------------------------------------------------
%	SECTION L
%----------------------------------------------------------------------------------------
\section*{L}

\begin{multicols*}{2}
\entry{Linguaggio}{Language}{Nome}{
    Un -- è un insieme di stringhe di caratteri, o simboli, appartenenti
    a un determinato \textbf{alfabeto}. In altri termini, si compone di una
    collezione di parole utilizzate per la comunicazione tra diverse entità o
    soggetti. 
    
    Dato un alfabeto $\Sigma$ con $n$ simboli $a_1, a_2, ..., a_n$,
    il -- $L$ che contiene tutte le parole $w$ formate da uno o più simboli
    di $\Sigma$, inclusa la \textbf{stringa vuota} $\epsilon$, è indicato
    formalmente nel seguente modo:
    \[
        L=\lbrace\epsilon, w_1, w_2, ..., w_k\rbrace,\hspace*{0.2cm}k\in N.
    \]

    $L$ potrebbe dunque essere l'insieme delle parole chiave di un -- di
    programmazione. Potrebbe anche essere il -- matematico, con i suoi simboli e
    le sue regole, o il -- musicale, con le sue note e le sue pause. Inoltre,
    esiste il -- vuoto, indicato con il simbolo $\emptyset$, che non contiene
    alcuna parola. Se con $\Sigma^*$  si indica l'insieme di tutte le parole che
    si possono formare con i simboli dell'alfabeto $\Sigma$, allora formalmente
    il -- $L$ è un sottoinsieme, finito o infinito, di $\Sigma^*$. Per
    esempio il -- matematico è intrinsecamente infinito: la sua natura dinamica
    implica l'aggiunta costante di nuovi termini e simboli e la struttura
    ricorsiva delle sue regole generative permette la creazione di un numero 
    illimitato di parole.
    
    La nozione di \textbf{linguaggio formale} è uno strumento
    potente che trova applicazioni in diversi campi, come la teoria della
    computazione e l'intelligenza artificiale. 
    
    Le caratteristiche che distinguono un -- sono il suo alfabeto (i
    simboli utilizzati per costruire le parole), la \textbf{grammatica} (
    l'insieme di regole che definiscono la struttura sintattica), la \textbf{semantica}
    (il significato che si attribuisce alle stringhe) e la \textbf{pragmatica}
    (l'analisi dei contesti nei quali le frasi assumono un significato specifico).

    In generale, si differenziano i \textbf{linguaggi naturali}, utilizzati per
    l'interazione tra individui in un contesto sociale, dai -- artificiali,
    creati per scopi specifici. I -- naturali sono caratterizzati da una
    struttura complessa e flessibile, che si è evoluta nel tempo attraverso
    l'uso quotidiano. Esempi di -- naturali sono l'italiano, l'inglese, il
    cinese e lo spagnolo. I -- artificiali, invece, sono progettati per
    soddisfare esigenze specifiche e sono spesso caratterizzati da una struttura
    più rigida e precisa. Esempi di -- artificiali sono il linguaggio C++ per la
    programmazione in informatica, il linguaggio XML per la formattazione delle
    comunicazioni tecniche e il linguaggio SQL per la gestione di database.    

    Ci sono quindi due campi di studio distinti: la teoria dei -- formali e la
    teoria dei -- naturali. I -- formali sono utilizzati per rappresentare e
    analizzare formalmente diversi tipi di dati, tra cui i linguaggi di
    programmazione, le espressioni regolari, i linguaggi di markup, ecc.
    Nello studio di questi --, si analizzano le proprietà, le strutture e le
    relazioni con vari modelli matematici come gli automi finiti, gli automi a
    pila, le macchine astratte, ecc., in grado di rappresentarli. D'altra parte,
    lo studio dei -- naturali riguarda l'analisi e la comprensione dei modelli
    linguistici nella comunicazione interpersonale.

    A causa della variabilità e della complessità dei -- naturali, non è
    possibile raggiungere un livello di completezza, efficienza e formalizzazione
    totale. Cioè, dal punto di vista matematico, le specifiche permettono di
    sviluppare strumenti di elevata efficacia per l'elaborazione dei - artificiali,
    si pensi al componente di un compilatore per l'analisi lessicale, mentre non
    si raggiunge lo stesso grado di perfezione nel trattamento dei - naturali.
    Ad esempio, la traduzione automatica da una lingua all'altra non sempre
    produce i risultati desiderati, a causa dell'\textit{ambiguità}\footnote{Si consideri la seguente
    frase italiana: "\textit{Mario dorme sugli allori}", può essere considerata ambigua
    perché la parola "\textit{allori}" ha diverse interpetazioni: letterale,
    cioè Mario ha allestito un'amaca tra due allori e sta dormendo lì, e
    figurata, Mario sta riposando sui suoi successi.} intrinseca delle lingue
    naturali. Inoltre, un -- scritto si presta meglio alla traduzione meccanica
    poiché le parole sono chiaramente separate da spazi bianchi, mentre nel
    formato vocale il segnale acustico continuo, rende più complesso distinguere
    nettamente le parole. Così, la ricerca scientifica nel campo della traduzione
    automatica affronta la sfida di gestire le sfumature linguistiche, i contesti
    culturali e le ambiguità dei -- naturali che rendono il processo di traduzione
    complesso e suscettibile di errori. Comunque, un certo grado di automazione
    può essere raggiunto anche con i linguaggi naturali, allorché si restringe
    il vocabolario a parole specifiche per comporre frasi precise e prive di
    ambiguità. In questo contesto, un esempio concreto di automazione si trova
    spesso nei messaggi trasmessi nelle stazioni ferroviarie, negli annunci
    aeroportuali o nei sistemi di guida vocale.

    La distinzione tra -- naturali e formali non è però sempre netta e esistono
    -- ibridi che combinano caratteristiche di entrambi. Ad esempio, il linguaggio
    matematico può essere considerato un -- ibrido, in quanto presenta aspetti
    sia naturali che artificiali.

    La storia della teoria dei -- formali è strettamente intrecciata con lo
    sviluppo della matematica, della logica e dell'informatica. Le prime
    formulazioni di -- formali risalgono agli inizi del XX secolo, quando
    matematici come Hilbert e Gödel stavano investigando i fondamenti della
    matematica e della logica. 

    Tuttavia, il vero impulso allo studio dei -- formali è arrivato negli anni
    '50 e '60 del XX secolo, con il lavoro pionieristico di figure come Noam
    Chomsky, Alonzo Church e Alan Turing. Chomsky ha introdotto la gerarchia
    che porta il suo nome, una classficazione dei -- formali in base alla loro
    complessità, che ha contribuito alla comprensione della struttura dei --
    e all'elaborazione di grammatiche formali. Invece, Church e Turing hanno
    sviluppato modelli computazionali fondamentali come la macchina di Turing e
    il \textbf{calcolo lambda}, che hanno dimostrato l'equivalenza tra diversi
    formalismi di calcolo e hanno stabilito i limiti della \textbf{computabilità}.
}

    \entry{Linguaggio di programmazione}{Programming language}{Nome}{I linguaggio
    di programmazione}

    \entry{Linguaggio formale}{Formal language}{Nome}{\textbf{Vd. Linguaggio}}
\end{multicols*}

%----------------------------------------------------------------------------------------
%	SECTION P 
%----------------------------------------------------------------------------------------
\section*{P}
\begin{multicols*}{2}
    \entry{Parentesi ben bilanciate}{Well-balanced parentheses}{Nome}{
        Dato un linguaggio
    }
\end{multicols*}


%----------------------------------------------------------------------------------------
%	SECTION S 
%----------------------------------------------------------------------------------------
\section*{S}

\begin{multicols*}{2}
\entry{Stringa}{String}{Nome} {Sinonimo di \textbf{parola}. Termine utilizzato
per indicare una sequenza finita di caratteri scelti da un \textbf{alfabeto}.
Questi oggetti hanno una lunghezza definita come \textit{il numero di posizioni
occupate dai simboli nella --}. Tuttavia, è abbastanza comune definire il
concetto di lunghezza con la frase: "il numero di simboli della stringa".
Sebbene sia un'espressione accettabile, è formalmente incorretta. Infatti, ogni
-- binaria ha solo due simboli, 0 e 1, che possono anche essere ripetuti zero
volte.

La lunghezza di una parola $w$, denota con $\left\vert w\right\vert$ (letto
\textit{modulo di w} oppure \textit{lunghezza di w}), rappresenta il numero di
posizioni occupate dai simboli in essa. La -- \textit{vuota} ha zero posizioni
disponibili per i simboli, viene indicata con la lettera greca $\epsilon$, e 
la sua lunghezza è $\left\vert\epsilon\right\vert=0$. 
}
\end{multicols*}

%------------------------------------------------
\end{document}